export declare type Unionized<Record, TaggedRecord> = {
    _Tags: keyof TaggedRecord;
    _Record: Record;
    _Union: TaggedRecord[keyof TaggedRecord];
    is: Predicates<TaggedRecord>;
    as: Casts<Record, TaggedRecord>;
    match: Match<Record, TaggedRecord>;
} & Creators<Record, TaggedRecord>;
export declare type Creators<Record, TaggedRecord> = {
    [T in keyof Record]: (value: Record[T]) => TaggedRecord[keyof TaggedRecord];
};
export declare type Predicates<TaggedRecord> = {
    [T in keyof TaggedRecord]: (variant: TaggedRecord[keyof TaggedRecord]) => variant is TaggedRecord[T];
};
export declare type Casts<Record, TaggedRecord> = {
    [T in keyof Record]: (variant: TaggedRecord[keyof TaggedRecord]) => Record[T];
};
export declare type Match<Record, TaggedRecord> = {
    <A>(cases: Cases<Record, keyof Record, A>): (variant: TaggedRecord[keyof TaggedRecord]) => A;
    <K extends keyof Record, A>(cases: Cases<Record, K, A>, fallback: (tag: keyof Record) => A): (variant: TaggedRecord[keyof TaggedRecord]) => A;
};
export declare type Cases<Record, K extends keyof Record, A> = {
    [T in K]: (value: Record[T]) => A;
};
export declare type MultiValueVariants<Record extends DictRecord, TagProp extends string> = {
    [T in keyof Record]: {
        [_ in TagProp]: T;
    } & Record[T];
};
export declare type SingleValueVariants<Record, TagProp extends string, ValProp extends string> = {
    [T in keyof Record]: {
        [_ in TagProp]: T;
    } & {
        [_ in ValProp]: Record[T];
    };
};
export declare type DictRecord = {
    [tag: string]: {
        [field: string]: any;
    };
};
/**
 * Create a tagged union from a record mapping tags to value types, along with associated
 * variant constructors, type predicates and `match` function.
 *
 * @param record A record mapping tags to value types. The actual values of the record don't
 * matter; they're just used in the types of the resulting tagged union. See `ofType`.
 * @param tagProp An optional custom name for the tag property of the union.
 * @param valProp An optional custom name for the value property of the union. If not specified,
 * the value must be a dictionary type.
 */
export declare function unionize<Record extends DictRecord>(record: Record): Unionized<Record, MultiValueVariants<Record, 'tag'>>;
export declare function unionize<Record extends DictRecord, TagProp extends string>(record: Record, tagProp: TagProp): Unionized<Record, MultiValueVariants<Record, TagProp>>;
export declare function unionize<Record, TagProp extends string, ValProp extends string>(record: Record, tagProp: TagProp, valProp: ValProp): Unionized<Record, SingleValueVariants<Record, TagProp, ValProp>>;
/**
 * Creates a pseudo-witness of a given type. That is, it pretends to return a value of
 * type `T` for any `T`, but it's really just returning `undefined`. This white lie
 * allows convenient expression of the value types in the record you pass to `unionize`.
 */
export declare const ofType: <T>() => T;
export default unionize;
